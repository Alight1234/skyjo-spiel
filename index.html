<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyjo Multiplayer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #0f172a; /* bg-slate-900 */
            color: #f1f5f9; /* bg-slate-100 */
            min-height: 100vh;
            overflow: hidden;
        }

        /* --- Einheitliche Kartengrößen --- */
        .card {
            box-sizing: border-box !important;
            width: 60px !important;
            height: 85px !important;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden !important;
            padding: 0 !important;
            margin: 0 !important;
            border: 2px solid #334155; /* border-slate-700 */
            user-select: none;
        }

        .card.face-down {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8) !important;
            color: white !important;
            font-size: 0.75rem !important;
            line-height: 1 !important;
            text-align: center !important;
            border-color: #60a5fa !important;
            white-space: nowrap !important;
            cursor: pointer;
        }

        .card.face-up {
            /* KORREKTUR: !important bei background-color entfernt, damit data-value greift */
            background-color: #1e293b; 
            border-color: #475569 !important;
            font-size: 1.75rem !important;
            font-weight: 700 !important;
            border: 2px solid #334155;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        
        /* Karten-Farben basierend auf Wert */
        .card[data-value="-2"] { background-color: #ef4444; color: white; border-color: #f87171; } /* red-500 */
        .card[data-value="-1"] { background-color: #ec4899; color: white; border-color: #f9a8d4; } /* pink-500 */
        .card[data-value="0"]  { background-color: #64748b; color: white; border-color: #94a3b8; } /* slate-500 */
        .card[data-value="1"], .card[data-value="2"], .card[data-value="3"], .card[data-value="4"] { 
            background-color: #22c55e; color: white; border-color: #4ade80; /* green-500 */
        }
        .card[data-value="5"], .card[data-value="6"], .card[data-value="7"], .card[data-value="8"] { 
            background-color: #eab308; color: white; border-color: #fde047; /* yellow-500 */
        }
        .card[data-value="9"], .card[data-value="10"], .card[data-value="11"], .card[data-value="12"] { 
            background-color: #f97316; color: white; border-color: #fb923c; /* orange-500 */
        }
        
        /* Spezial-Styling für "weggeworfene" Spalten */
        .card.discarded {
            background-color: #334155; /* bg-slate-700 */
            border-color: #475569; /* bg-slate-600 */
            opacity: 0.3;
            color: #64748b;
            cursor: not-allowed;
        }

        /* Deck & Ablagestapel */
        .deck-pile {
            border: 2px dashed #475569; /* border-slate-600 */
        }
        .deck-pile:hover {
            border-color: white;
        }
        .card.placeholder {
            border: 2px dashed #334155; /* border-slate-700 */
            background-color: transparent !important;
            box-shadow: none;
            cursor: default;
        }
        
        /* Hervorhebung */
        .card.highlight-player {
            box-shadow: 0 0 15px 5px #3b82f6; /* Blauer Schein */
            border-color: white;
            transform: scale(1.05);
        }
        /* HINZUGEFÜGT: Highlight für KI-Züge */
        .card.highlight-ai {
            box-shadow: 0 0 15px 5px #ef4444; /* Roter Schein */
            border-color: white;
            transform: scale(1.05);
        }
        .highlight-grid {
            box-shadow: 0 0 25px 10px #3b82f6; /* Stärkerer blauer Schein */
            border-radius: 8px; /* Passend zu den Karten */
            transition: box-shadow 0.2s ease-in-out;
        }
        
        /* Modale (Lobby, Rundenende, Verlassen) */
        .modal-backdrop {
            background-color: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
        }
        
        /* Lade-Spinner für API-Aufrufe */
        #loader {
            background-color: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
            z-index: 60;
        }
        .spinner {
            border-top-color: #3b82f6; /* Lade-Farbe (blau) */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast-Nachricht (Beitreten/Verlassen) */
        #toast {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(-100px);
            opacity: 0;
        }
        #toast.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body class="relative">

    <!-- Lade-Overlay (Startet sichtbar, wird bei Auth ausgeblendet) -->
    <div id="loader" class="fixed inset-0 w-full h-full flex items-center justify-center z-50">
        <div class="flex flex-col items-center">
            <div class="spinner w-16 h-16 border-8 border-slate-700 rounded-full"></div>
            <p id="loader-text" class="text-xl text-white mt-4 font-semibold">Verbinde mit Server...</p>
        </div>
    </div>

    <!-- Toast-Nachricht (für Spieler beigetreten/verlassen) -->
    <div id="toast" class="fixed top-4 left-1/2 -translate-x-1/2 bg-green-600 text-white py-3 px-6 rounded-lg shadow-lg z-50">
        <span id="toast-message">Spieler beigetreten!</span>
    </div>

    <!-- HINZUGEFÜGT: "Spiel verlassen" Button -->
    <button id="leave-game-button" class="fixed top-4 left-4 w-12 h-12 bg-red-600 hover:bg-red-700 text-white font-bold text-2xl rounded-full shadow-lg z-20 flex items-center justify-center hidden" title="Spiel verlassen">
        X
    </button>

    <!-- Anzeige für den Punktestand der letzten Runde -->
    <div id="previous-score-display" class="fixed top-4 right-4 bg-slate-800/80 backdrop-blur-sm p-3 rounded-lg shadow-lg z-20 hidden border border-slate-700 max-w-xs">
        <h3 class="text-sm font-bold text-yellow-400 mb-2 border-b border-slate-600 pb-1">Letzte Runde</h3>
        <div id="previous-scores-list" class="text-xs space-y-1">
            <!-- Punktestände werden hier eingefügt -->
        </div>
    </div>

    <!-- Lobby-Bildschirm -->
    <div id="lobby-screen" class="fixed inset-0 w-full h-full flex items-center justify-center z-30 modal-backdrop p-4 hidden">
        <div id="lobby-start" class="bg-slate-800 p-8 rounded-lg shadow-2xl border border-slate-700 max-w-md w-full text-center">
            <h2 class="text-4xl font-bold mb-8 text-blue-400">Skyjo Multiplayer</h2>
            
            <button id="create-game-button" class="mb-6 bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-colors w-full">
                Neues Spiel erstellen
            </button>
            
            <hr class="border-slate-600 my-6">

            <div class="text-left">
                <label for="game-id-input" class="block text-lg font-semibold mb-2 text-slate-200">Spiel-ID beitreten</label>
                <div class="flex gap-2">
                    <input type="text" id="game-id-input" placeholder="Spiel-ID einfügen..." class="w-full p-3 bg-slate-700 border border-slate-600 rounded-lg text-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="join-game-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors">
                        Beitreten
                    </button>
                </div>
                <p id="join-error" class="text-red-400 text-sm mt-2 h-4"></p>
            </div>
        </div>

        <!-- Warte-Bildschirm (nach Erstellen/Beitreten) -->
        <div id="lobby-wait" class="hidden bg-slate-800 p-8 rounded-lg shadow-2xl border border-slate-700 max-w-md w-full text-center">
            <h2 class="text-2xl font-bold mb-4 text-yellow-400">Warte auf Spieler...</h2>
            <p class="text-slate-300 mb-4">Teile diese Spiel-ID mit deinen Freunden:</p>
            <div class="flex justify-center mb-6">
                <input type="text" id="game-id-display" readonly class="p-3 bg-slate-900 border border-slate-700 rounded-l-lg text-lg text-white text-center font-mono focus:outline-none select-all w-full max-w-xs">
                <button id="copy-game-id-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-r-lg text-lg transition-colors">
                    Kopieren
                </button>
            </div>

            <!-- HINZUGEFÜGT: Spiel-Einstellungen (Nur Host) -->
            <div id="game-settings" class="space-y-4 text-left my-6 border-t border-b border-slate-700 py-6">
                <h3 class="text-xl font-semibold mb-3 text-slate-200 text-center">Spiel-Einstellungen (Nur Host)</h3>
                
                <div>
                    <label for="setting-goal-score" class="block text-lg font-semibold mb-2 text-slate-200">Ziel-Punktestand (Spiel endet)</label>
                    <select id="setting-goal-score" class="setting-input w-full p-3 bg-slate-700 border border-slate-600 rounded-lg text-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="50">50 Punkte</option>
                        <option value="100" selected>100 Punkte</option>
                        <option value="150">150 Punkte</option>
                    </select>
                </div>
                
                <div>
                    <label for="setting-flipped-cards" class="block text-lg font-semibold mb-2 text-slate-200">Aufgedeckte Startkarten</label>
                    <select id="setting-flipped-cards" class="setting-input w-full p-3 bg-slate-700 border border-slate-600 rounded-lg text-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="1">1 Karte</option>
                        <option value="2" selected>2 Karten</option>
                        <option value="3">3 Karten</option>
                    </select>
                </div>

                <div>
                    <label for="setting-num-ai" class="block text-lg font-semibold mb-2 text-slate-200">KI-Gegner hinzufügen</label>
                    <select id="setting-num-ai" class="setting-input w-full p-3 bg-slate-700 border border-slate-600 rounded-lg text-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="0" selected>Keine</option>
                        <option value="1">1 KI-Gegner</option>
                        <option value="2">2 KI-Gegner</option>
                        <option value="3">3 KI-Gegner</option>
                    </select>
                </div>
                
                <div>
                    <label for="setting-ai-difficulty" class="block text-lg font-semibold mb-2 text-slate-200">KI-Schwierigkeit</label>
                    <select id="setting-ai-difficulty" class="setting-input w-full p-3 bg-slate-700 border border-slate-600 rounded-lg text-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="EASY">Einfach</option>
                        <option value="MEDIUM" selected>Mittel</option>
                        <option value="HARD">Schwer</option>
                    </select>
                </div>
            </div>

            <h3 class="text-xl font-semibold mb-3 text-slate-200">Spieler in der Lobby:</h3>
            <ul id="player-list" class="space-y-2 text-lg text-blue-300 mb-8 min-h-[50px]">
                <!-- Spieler werden hier eingefügt -->
            </ul>

            <button id="start-game-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-colors w-full" disabled>
                Spiel starten (min. 2 Spieler)
            </button>
            <button id="back-to-lobby-button" class="mt-4 text-slate-400 hover:text-white transition-colors">
                Zurück
            </button>
        </div>
    </div>


    <!-- Spiel-Container -->
    <div id="game-container" class="w-full max-w-7xl mx-auto p-4 hidden mt-4">
        
        <!-- Gegner-Bereich (wird dynamisch gefüllt) -->
        <div id="opponents-area" class="flex flex-wrap justify-center gap-6 mb-4">
            <!-- Gegner-Container werden hier eingefügt -->
        </div>

        <!-- Spiel-Bereich (Mitte) -->
        <div id="deck-area" class="flex justify-center items-center gap-2 mb-4">
            <!-- Nachziehstapel -->
            <div id="deck-pile" class="card face-down deck-pile" title="Vom Stapel ziehen">
                SKYJO
            </div>
            <!-- Gezogene Karte (Platzhalter) -->
            <div id="drawn-card-area" class="card placeholder" title="Gezogene Karte">
                <!-- Gezogene Karte wird hier angezeigt -->
            </div>
            <!-- Ablagestapel -->
            <div id="discard-pile" class="card face-up" title="Vom Ablagestapel ziehen">
                <!-- Startkarte wird hier eingefügt -->
            </div>
        </div>
        
        <!-- Spieler-Bereich -->
        <div id="player-area" class="relative">
            <!-- Anzeige "Du bist dran" -->
            <div id="turn-indicator" class="absolute -top-10 left-1/2 -translate-x-1/2 bg-green-500 text-white font-bold py-2 px-6 rounded-full shadow-lg text-lg transition-all opacity-0 scale-90">
                Du bist dran!
            </div>
            <h2 class="text-xl font-bold mb-2 text-center text-blue-400">Dein Feld</h2>
            <div id="player-grid" class="grid grid-cols-4 gap-y-2 gap-x-4 justify-center mb-2">
                <!-- Spieler-Karten werden hier eingefügt -->
            </div>
            <p class="text-center text-lg font-semibold">Punkte: <span id="player-score">0</span></p>
        </div>
        
        <!-- Nachrichten-Bereich -->
        <div id="message-area" class="text-center text-lg font-semibold text-yellow-400 mt-4 h-12">
            Willkommen bei Skyjo!
        </div>

    </div>
    
    <!-- End-of-Round Modal -->
    <div id="modal" class="fixed inset-0 w-full h-full items-center justify-center hidden z-40 modal-backdrop p-4">
        <div class="bg-slate-800 p-8 rounded-lg shadow-2xl border border-slate-700 text-center max-w-md w-full">
            <h2 id="modal-title" class="text-3xl font-bold mb-4">Runde beendet!</h2>
            <div id="modal-scores-container" class="text-lg mb-6 space-y-4">
                <!-- Runden- und Gesamtpunkte werden hier dynamisch eingefügt -->
            </div>
            <p id="modal-winner" class="text-2xl font-semibold mb-8"></p>
            <button id="next-round-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors w-full">
                Nächste Runde
            </button>
        </div>
    </div>

    <!-- HINZUGEFÜGT: "Spiel verlassen" Bestätigungs-Modal -->
    <div id="leave-confirm-modal" class="fixed inset-0 w-full h-full items-center justify-center hidden z-50 modal-backdrop p-4">
        <div class="bg-slate-800 p-8 rounded-lg shadow-2xl border border-slate-700 text-center max-w-md w-full">
            <h2 class="text-3xl font-bold mb-4 text-red-400">Spiel verlassen?</h2>
            <p class="text-lg text-slate-300 mb-8">Möchtest du das laufende Spiel wirklich verlassen und zur Lobby zurückkehren?</p>
            
            <div class="flex gap-4">
                <button id="leave-confirm-cancel-button" class="bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors w-full">
                    Abbrechen
                </button>
                <button id="leave-confirm-confirm-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors w-full">
                    Verlassen
                </button>
            </div>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        // ===================================================================
        // HIER DEINE FIREBASE-KONFIGURATION EINFÜGEN (aus Schritt 1.3 der Anleitung)
        // ===================================================================
        // 1. Ersetze dies mit dem Objekt aus deinen Firebase-Projekteinstellungen
        const firebaseConfig = {
          apiKey: "AIzaSyAeNB6gEFnKRPicGn0UYgrjG1m6lHllAOA",
          authDomain: "skyjo-multiplayer.firebaseapp.com",
          projectId: "skyjo-multiplayer",
          storageBucket: "skyjo-multiplayer.firebasestorage.app",
          messagingSenderId: "514693348398",
          appId: "1:514693348398:web:279883b9c88fc33e82b3bf",
          measurementId: "G-Q3X1NC2S6F"
        };

        // 2. Ersetze dies mit deiner Projekt-ID (muss mit der oben übereinstimmen)
        const appId = "skyjo-multiplayer"; 
        // ===================================================================


        // Firebase-Module importieren
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            addDoc, 
            updateDoc, 
            deleteDoc,
            onSnapshot, 
            collection, 
            query, 
            where, 
            writeBatch,
            serverTimestamp,
            arrayUnion,
            arrayRemove
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Globale Variablen für Firebase und Authentifizierung
        let db, auth, userId;
        let currentGameId = null;
        let unsubscribeGameListener = null;

        // DOM-Elemente
        const loaderEl = document.getElementById('loader');
        const loaderTextEl = document.getElementById('loader-text');
        
        const lobbyScreenEl = document.getElementById('lobby-screen');
        const lobbyStartEl = document.getElementById('lobby-start');
        const lobbyWaitEl = document.getElementById('lobby-wait');
        const createGameButtonEl = document.getElementById('create-game-button');
        const gameIdInputEl = document.getElementById('game-id-input');
        const joinGameButtonEl = document.getElementById('join-game-button');
        const joinErrorEl = document.getElementById('join-error');
        const gameIdDisplayEl = document.getElementById('game-id-display');
        const copyGameIdButtonEl = document.getElementById('copy-game-id-button');
        const playerListEl = document.getElementById('player-list');
        // KORREKTUR: Fehlende DOM-Elemente hinzugefügt
        const startGameButtonEl = document.getElementById('start-game-button');
        const backToLobbyButtonEl = document.getElementById('back-to-lobby-button');
        const settingGoalScoreEl = document.getElementById('setting-goal-score');
        const settingFlippedCardsEl = document.getElementById('setting-flipped-cards');
        const settingNumAiEl = document.getElementById('setting-num-ai');
        const settingAiDifficultyEl = document.getElementById('setting-ai-difficulty');
        const allSettingsInputs = document.querySelectorAll('.setting-input');


        const gameContainerEl = document.getElementById('game-container');
        const opponentsAreaEl = document.getElementById('opponents-area');
        const deckPileEl = document.getElementById('deck-pile');
        const drawnCardAreaEl = document.getElementById('drawn-card-area');
        const discardPileEl = document.getElementById('discard-pile');
        const playerAreaEl = document.getElementById('player-area');
        const turnIndicatorEl = document.getElementById('turn-indicator');
        const playerGridEl = document.getElementById('player-grid');
        const playerScoreEl = document.getElementById('player-score');
        const messageEl = document.getElementById('message-area');
        const previousScoreDisplayEl = document.getElementById('previous-score-display');
        const previousScoresListEl = document.getElementById('previous-scores-list');

        const modalEl = document.getElementById('modal');
        const modalTitleEl = document.getElementById('modal-title');
        const modalScoresContainerEl = document.getElementById('modal-scores-container');
        const modalWinnerEl = document.getElementById('modal-winner');
        const nextRoundButtonEl = document.getElementById('next-round-button');

        const toastEl = document.getElementById('toast');
        const toastMessageEl = document.getElementById('toast-message');

        const leaveGameButtonEl = document.getElementById('leave-game-button');
        const leaveConfirmModalEl = document.getElementById('leave-confirm-modal');
        const leaveConfirmCancelButtonEl = document.getElementById('leave-confirm-cancel-button');
        const leaveConfirmConfirmButtonEl = document.getElementById('leave-confirm-confirm-button');


        // HINZUGEFÜGT: KI-Konstanten
        const AI_DIFFICULTY = {
            EASY: {
                DISCARD_TAKE_THRESHOLD: 2, // Nimmt nur sehr gute Karten vom Ablagestapel
                DECK_SWAP_GOOD_CARD_THRESHOLD: 2, // Tauscht nur sehr gute gezogene Karten
                ASSUMED_FACEDOWN_VALUE: 8, // Geht von hohem Wert bei verdeckten Karten aus
            },
            MEDIUM: {
                DISCARD_TAKE_THRESHOLD: 4, // Standard
                DECK_SWAP_GOOD_CARD_THRESHOLD: 3, // Standard
                ASSUMED_FACEDOWN_VALUE: 6, // Standard
            },
            HARD: {
                DISCARD_TAKE_THRESHOLD: 3, // Wählerischer, da sie auf Spalten hofft
                DECK_SWAP_GOOD_CARD_THRESHOLD: 1, // Tauscht auch mittelmäßige Karten, um aufzudecken
                ASSUMED_FACEDOWN_VALUE: 5, // Geht von niedrigerem Wert aus
            }
        };


        // Sammlungspfad-Funktion
        const getGameCollectionPath = () => `/artifacts/${appId}/public/data/skyjoGames`;


        /**
         * Zeigt eine kurze Toast-Nachricht an
         */
        function showToast(message, isError = false) {
            toastMessageEl.textContent = message;
            toastEl.classList.toggle('bg-red-600', isError);
            toastEl.classList.toggle('bg-green-600', !isError);
            toastEl.classList.add('show');
            setTimeout(() => {
                toastEl.classList.remove('show');
            }, 3000);
        }

        /**
         * Setup aller permanenten Event-Listener (Lobby, Modals etc.)
         */
        function setupLobbyListeners() {
            createGameButtonEl.addEventListener('click', createNewGame);
            joinGameButtonEl.addEventListener('click', joinGame);
            startGameButtonEl.addEventListener('click', startGame);
            
            copyGameIdButtonEl.addEventListener('click', () => {
                gameIdDisplayEl.select();
                try {
                    document.execCommand('copy');
                    showToast("Spiel-ID kopiert!");
                } catch (err) {
                    showToast("Kopieren fehlgeschlagen", true);
                }
            });

            // HINZUGEFÜGT: Listener für Einstellungs-Änderungen (nur Host)
            allSettingsInputs.forEach(input => {
                input.addEventListener('change', updateGameSettings);
            });

            backToLobbyButtonEl.addEventListener('click', () => {
                lobbyStartEl.classList.remove('hidden');
                lobbyWaitEl.classList.add('hidden');
            });
            
            // HINZUGEFÜGT: Listener für "Spiel verlassen"
            leaveGameButtonEl.addEventListener('click', () => {
                leaveConfirmModalEl.classList.remove('hidden');
                leaveConfirmModalEl.classList.add('flex');
            });
            leaveConfirmCancelButtonEl.addEventListener('click', () => {
                leaveConfirmModalEl.classList.add('hidden');
                leaveConfirmModalEl.classList.remove('flex');
            });
            leaveConfirmConfirmButtonEl.addEventListener('click', leaveGame);

            // Listener für "Nächste Runde"
            nextRoundButtonEl.addEventListener('click', startNextRound);
        }

        /**
         * Setup der Event-Listener für das Spielbrett (Kartenstapel)
         */
        function setupGameListeners() {
            deckPileEl.addEventListener('click', onDeckDraw);
            discardPileEl.addEventListener('click', onDiscardPileClick);
            drawnCardAreaEl.addEventListener('click', onDrawnCardClick); // Klick auf gezogene Karte = Ablegen
        }


        /**
         * Initialisiert Firebase und startet die Authentifizierung
         */
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        // Benutzer ist anonym angemeldet
                        userId = user.uid;
                        
                        // HINZUGEFÜGT: Prüfen, ob ein Spiel gespeichert ist
                        const savedGameId = localStorage.getItem('skyjoGameId');
                        if (savedGameId) {
                            loaderTextEl.textContent = "Verbinde mit letztem Spiel...";
                            // Versuche, dem Spiel wieder beizutreten
                            if (await subscribeToGame(savedGameId)) {
                                // Erfolg, Loader wird in handleGameUpdate ausgeblendet
                            } else {
                                // Spiel existiert nicht mehr, zurück zur Lobby
                                resetToLobby(true); // true = auch localStorage löschen
                            }
                        } else {
                            // Kein gespeichertes Spiel, Lobby anzeigen
                            loaderEl.classList.add('hidden');
                            lobbyScreenEl.classList.remove('hidden');
                            lobbyStartEl.classList.remove('hidden');
                        }
                    } else {
                        // Benutzer nicht angemeldet, versuche anonymen Login
                        await signInAnonymously(auth);
                    }
                });
            } catch (error) {
                console.error("Firebase Init Fehler:", error);
                loaderTextEl.textContent = "Server-Fehler. Bitte neu laden.";
                // KORREKTUR: Fehlerbehandlung beim anonymen Login
                loaderEl.classList.add('hidden');
                lobbyScreenEl.classList.remove('hidden');
                lobbyStartEl.classList.remove('hidden');
                showToast("Verbindung fehlgeschlagen!", true);
            }
        }

        /**
         * Erstellt ein neues Spiel-Dokument in Firestore
         */
        async function createNewGame() {
            loaderEl.classList.remove('hidden');
            loaderTextEl.textContent = "Erstelle Spiel...";

            // HINZUGEFÜGT: Einstellungen aus der Lobby lesen
            const settings = {
                goalScore: parseInt(settingGoalScoreEl.value, 10),
                flippedCards: parseInt(settingFlippedCardsEl.value, 10),
                numAI: parseInt(settingNumAiEl.value, 10),
                aiDifficulty: settingAiDifficultyEl.value
            };

            try {
                const player = {
                    id: userId,
                    name: `Spieler ${Math.floor(Math.random() * 1000)}`,
                    isHost: true,
                    isAI: false, // HINZUGEFÜGT
                    grid: [],
                    score: 0,
                    totalScore: 0
                };

                const gameDoc = {
                    hostId: userId,
                    players: [player],
                    status: "lobby", // 'lobby', 'playing', 'round-over', 'game-over'
                    deck: [],
                    discardPile: [],
                    currentPlayerIndex: 0,
                    turnPhase: 'DRAW',
                    selectedCard: null,
                    lastRoundTriggered: false,
                    playerWhoEndedRoundId: null,
                    settings: settings, // HINZUGEFÜGT: Einstellungen speichern
                    createdAt: serverTimestamp(),
                    lastRoundScores: [] // Für die Anzeige
                };
                
                const gameCollectionRef = collection(db, getGameCollectionPath());
                const docRef = await addDoc(gameCollectionRef, gameDoc);
                
                await subscribeToGame(docRef.id);

            } catch (error) {
                console.error("Fehler beim Erstellen des Spiels:", error);
                loaderEl.classList.add('hidden');
                showToast("Spielerstellung fehlgeschlagen!", true);
            }
        }

        /**
         * Tritt einem bestehenden Spiel bei
         */
        async function joinGame() {
            const gameId = gameIdInputEl.value.trim();
            if (!gameId) {
                joinErrorEl.textContent = "Bitte eine ID eingeben.";
                return;
            }
            
            loaderEl.classList.remove('hidden');
            loaderTextEl.textContent = "Trete Spiel bei...";
            joinErrorEl.textContent = "";

            try {
                const gameDocRef = doc(db, getGameCollectionPath(), gameId);
                const gameDocSnap = await getDoc(gameDocRef);

                if (!gameDocSnap.exists()) {
                    throw new Error("Spiel nicht gefunden.");
                }

                const game = gameDocSnap.data();

                if (game.status !== 'lobby') {
                    throw new Error("Spiel läuft bereits.");
                }

                // HINZUGEFÜGT: Check gegen (Menschen + KI)
                const totalPlayers = game.players.length + (game.settings.numAI || 0);
                if (totalPlayers >= 4) {
                     throw new Error("Spiel ist voll (max. 4 Spieler, inkl. KI).");
                }


                if (game.players.some(p => p.id === userId)) {
                    // Spieler ist bereits im Spiel, einfach beitreten
                } else {
                    const player = {
                        id: userId,
                        name: `Spieler ${Math.floor(Math.random() * 1000)}`,
                        isHost: false,
                        isAI: false, // HINZUGEFÜGT
                        grid: [],
                        score: 0,
                        totalScore: 0
                    };
                    await updateDoc(gameDocRef, {
                        players: arrayUnion(player)
                    });
                }
                
                await subscribeToGame(gameId);

            } catch (error) {
                console.error("Fehler beim Beitreten:", error);
                loaderEl.classList.add('hidden');
                joinErrorEl.textContent = error.message;
            }
        }

        /**
         * HINZUGEFÜGT: Funktion zum Aktualisieren der Spiel-Einstellungen (nur Host)
         */
        async function updateGameSettings() {
            if (!currentGameId) return;
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            
            // Sicherstellen, dass der aktuelle User der Host ist
            const game = (await getDoc(gameDocRef)).data();
            if (game.hostId !== userId) return;

            const settings = {
                goalScore: parseInt(settingGoalScoreEl.value, 10),
                flippedCards: parseInt(settingFlippedCardsEl.value, 10),
                numAI: parseInt(settingNumAiEl.value, 10),
                aiDifficulty: settingAiDifficultyEl.value
            };

            try {
                await updateDoc(gameDocRef, {
                    settings: settings
                });
            } catch (error) {
                console.error("Fehler beim Aktualisieren der Einstellungen:", error);
                showToast("Einstellungs-Fehler!", true);
            }
        }


        /**
         * Abonniert Echtzeit-Updates für ein Spiel
         */
        async function subscribeToGame(gameId) {
            currentGameId = gameId;
            // HINZUGEFÜGT: Spiel-ID im localStorage speichern
            localStorage.setItem('skyjoGameId', gameId);

            const gameDocRef = doc(db, getGameCollectionPath(), gameId);
            
            // Alten Listener kündigen, falls vorhanden
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
            }

            return new Promise((resolve, reject) => {
                unsubscribeGameListener = onSnapshot(gameDocRef, 
                    (docSnap) => {
                        if (docSnap.exists()) {
                            const game = docSnap.data();
                            game.id = docSnap.id;
                            handleGameUpdate(game);
                            resolve(true); // Erfolgreich verbunden
                        } else {
                            // Spiel wurde gelöscht (z.B. vom Host)
                            showToast("Das Spiel wurde beendet.", true);
                            resetToLobby(true); // true = auch localStorage löschen
                            reject(new Error("Spiel existiert nicht."));
                        }
                    }, 
                    (error) => {
                        console.error("Fehler beim Abonnieren des Spiels:", error);
                        showToast("Verbindung zum Spiel verloren!", true);
                        // KORREKTUR: Bei Fehler (z.B. Neuladen eines gelöschten Spiels)
                        loaderEl.classList.add('hidden'); // Ladebildschirm ausblenden
                        resetToLobby(true); // Zur Lobby zurückkehren
                        reject(error);
                    }
                );
            });
        }

        /**
         * HINZUGEFÜGT: Funktion zum Verlassen eines Spiels
         */
        async function leaveGame() {
            leaveConfirmModalEl.classList.add('hidden');
            leaveConfirmModalEl.classList.remove('flex');

            if (!currentGameId || !userId) return;

            loaderEl.classList.remove('hidden');
            loaderTextEl.textContent = "Verlasse Spiel...";

            try {
                const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
                const gameDocSnap = await getDoc(gameDocRef);

                if (gameDocSnap.exists()) {
                    const game = gameDocSnap.data();
                    const playerToRemove = game.players.find(p => p.id === userId);
                    
                    if (game.players.length === 1) {
                        // Letzter Spieler verlässt das Spiel, Spiel löschen
                        await deleteDoc(gameDocRef);
                    } else if (playerToRemove) {
                        let newHostId = game.hostId;
                        // Wenn der Host geht, einen neuen Host bestimmen
                        if (playerToRemove.isHost) {
                            const newHost = game.players.find(p => p.id !== userId);
                            if (newHost) {
                                newHost.isHost = true;
                                newHostId = newHost.id;
                                // Update des neuen Hosts (Rest der Spieler bleibt)
                                const updatedPlayers = game.players
                                    .filter(p => p.id !== userId)
                                    .map(p => p.id === newHostId ? newHost : p);
                                
                                await updateDoc(gameDocRef, {
                                    players: updatedPlayers,
                                    hostId: newHostId
                                });
                            }
                        } else {
                            // Normaler Spieler geht
                            await updateDoc(gameDocRef, {
                                players: arrayRemove(playerToRemove)
                            });
                        }
                    }
                }
            } catch (error) {
                console.error("Fehler beim Verlassen des Spiels:", error);
                showToast("Fehler beim Verlassen!", true);
            } finally {
                resetToLobby(true); // true = auch localStorage löschen
            }
        }

        /**
         * Setzt die UI zurück zur Lobby
         */
        function resetToLobby(clearLocalStorage = false) {
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
            currentGameId = null;
            
            // HINZUGEFÜGT: localStorage leeren, wenn explizit gefordert
            if (clearLocalStorage) {
                localStorage.removeItem('skyjoGameId');
            }

            // KORREKTUR: Stellt sicher, dass die richtigen Container angezeigt/versteckt werden
            loaderEl.classList.add('hidden');
            gameContainerEl.classList.add('hidden');
            leaveGameButtonEl.classList.add('hidden');
            modalEl.classList.add('hidden');
            previousScoreDisplayEl.classList.add('hidden');

            lobbyScreenEl.classList.remove('hidden');
            lobbyStartEl.classList.remove('hidden');
            lobbyWaitEl.classList.add('hidden');
            
            gameIdInputEl.value = "";
            joinErrorEl.textContent = "";
        }


        /**
         * Wird bei jeder Änderung am Spiel-Dokument aufgerufen
         */
        function handleGameUpdate(game) {
            // Toast-Nachrichten für beitretende/verlassene Spieler
            const lastKnownPlayers = JSON.parse(sessionStorage.getItem('skyjoPlayers') || '[]');
            const currentPlayers = game.players.map(p => p.name);
            
            const joined = currentPlayers.filter(p => !lastKnownPlayers.includes(p) && p !== '');
            const left = lastKnownPlayers.filter(p => !currentPlayers.includes(p) && p !== '');
            
            if (joined.length > 0 && lastKnownPlayers.length > 0) showToast(`${joined.join(', ')} ist beigetreten!`);
            if (left.length > 0) showToast(`${left.join(', ')} hat das Spiel verlassen.`, true);
            
            sessionStorage.setItem('skyjoPlayers', JSON.stringify(currentPlayers));

            // UI basierend auf Spielstatus aktualisieren
            if (game.status === 'lobby') {
                loaderEl.classList.add('hidden');
                gameContainerEl.classList.add('hidden');
                leaveGameButtonEl.classList.remove('hidden');
                modalEl.classList.add('hidden');
                
                lobbyScreenEl.classList.remove('hidden');
                lobbyStartEl.classList.add('hidden');
                lobbyWaitEl.classList.remove('hidden');
                
                gameIdDisplayEl.value = game.id;
                
                // Spielerliste rendern
                playerListEl.innerHTML = '';
                game.players.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = `${p.name} ${p.isHost ? '(Host)' : ''} ${p.id === userId ? '(Du)' : ''}`;
                    playerListEl.appendChild(li);
                });

                // HINZUGEFÜGT: Einstellungen im Wartebildschirm für alle sichtbar machen
                const amIHost = game.hostId === userId;
                settingGoalScoreEl.value = game.settings.goalScore;
                settingFlippedCardsEl.value = game.settings.flippedCards;
                settingNumAiEl.value = game.settings.numAI || 0;
                settingAiDifficultyEl.value = game.settings.aiDifficulty || 'MEDIUM';

                // Einstellungen für Nicht-Hosts deaktivieren
                allSettingsInputs.forEach(input => {
                    input.disabled = !amIHost;
                });
                document.getElementById('game-settings').style.display = amIHost ? 'block' : 'block'; // Oder für alle anzeigen, aber disabled


                // Start-Button für Host aktivieren/deaktivieren
                // HINZUGEFÜGT: KI-Spieler zur Zählung hinzufügen
                const humanPlayers = game.players.filter(p => !p.isAI).length;
                const aiPlayers = game.settings.numAI || 0;
                const totalPlayers = humanPlayers + aiPlayers;
                
                startGameButtonEl.style.display = amIHost ? 'block' : 'none';
                if (totalPlayers >= 2) {
                    startGameButtonEl.disabled = false;
                    startGameButtonEl.textContent = `Spiel starten (${totalPlayers} Spieler)`;
                } else {
                    startGameButtonEl.disabled = true;
                    startGameButtonEl.textContent = "Spiel starten (min. 1 Spieler)"; // Min 1 human + 1 AI
                }
                // Spezieller Fall: 1 Mensch + 1 AI
                if (humanPlayers === 1 && aiPlayers >= 1) {
                     startGameButtonEl.disabled = false;
                     startGameButtonEl.textContent = `Spiel starten (${totalPlayers} Spieler)`;
                }


            } else if (game.status === 'playing') {
                loaderEl.classList.add('hidden');
                lobbyScreenEl.classList.add('hidden');
                modalEl.classList.add('hidden');

                gameContainerEl.classList.remove('hidden');
                leaveGameButtonEl.classList.remove('hidden');

                // Punktestand der letzten Runde anzeigen (falls vorhanden)
                if (game.lastRoundScores && game.lastRoundScores.length > 0) {
                    previousScoresListEl.innerHTML = '';
                    game.lastRoundScores.forEach(s => {
                        const scoreEntry = document.createElement('div');
                        scoreEntry.className = `flex justify-between ${s.id === userId ? 'text-blue-300' : 'text-red-300'}`;
                        scoreEntry.innerHTML = `<span>${s.name}:</span> <span class="font-bold">${s.score}</span>`;
                        previousScoresListEl.appendChild(scoreEntry);
                    });
                    previousScoreDisplayEl.classList.remove('hidden');
                } else {
                    previousScoreDisplayEl.classList.add('hidden');
                }

                // Spielbrett rendern
                renderGame(game);

            } else if (game.status === 'round-over' || game.status === 'game-over') {
                loaderEl.classList.add('hidden');
                lobbyScreenEl.classList.add('hidden');
                gameContainerEl.classList.remove('hidden');
                
                renderGame(game); // Zeigt das finale aufgedeckte Brett
                showEndRoundModal(game);
            }
        }


        // ===================================================================
        //
        // SPIEL-LOGIK (Rendern, Züge etc.)
        //
        // ===================================================================

        function setMessage(msg) {
            messageEl.textContent = msg;
        }

        /**
         * Zeichnet das gesamte Spielbrett basierend auf dem 'game'-Objekt
         */
        function renderGame(game) {
            if (!game || !game.players || !userId) {
                console.error("Render-Fehler: Ungültiges Spiel-Objekt.", game);
                // KORREKTUR: Debug-Log hinzugefügt
                console.log("UserID:", userId, "Game-Objekt:", game);
                resetToLobby(); // Zurück zur Lobby bei ungültigem Status
                return;
            }

            const me = game.players.find(p => p.id === userId);
            const opponents = game.players.filter(p => p.id !== userId);

            if (!me) {
                 // Das ist normal, wenn ein Spieler gekickt wurde/geleaved hat
                 console.log("Spieler nicht mehr im Spiel gefunden. Kehre zur Lobby zurück.");
                 resetToLobby(true); // Spieler wurde gekickt o.Ä.
                 return;
            }

            // 1. Gegner rendern
            opponentsAreaEl.innerHTML = '';
            opponents.forEach(opp => {
                const oppContainer = document.createElement('div');
                oppContainer.className = 'flex flex-col items-center p-2 rounded-lg';
                // Gegner hervorheben, wenn er dran ist
                if (game.players[game.currentPlayerIndex].id === opp.id) {
                    oppContainer.classList.add('bg-red-900/50', 'shadow-lg');
                }

                let gridHtml = '<div class="grid grid-cols-4 gap-2 max-w-xs mx-auto mb-2">';
                opp.grid.forEach(card => {
                    if (card.discarded) {
                        gridHtml += `<div class="card discarded">X</div>`;
                    } else if (card.faceUp || game.status !== 'playing') { // Am Rundenende alles zeigen
                        gridHtml += `<div class="card face-up" data-value="${card.value}">${card.value}</div>`;
                    } else {
                        gridHtml += `<div class="card face-down">SKYJO</div>`;
                    }
                });
                gridHtml += '</div>';

                const totalScoreDisplay = game.status === 'lobby' ? '' : `| Gesamt: ${opp.totalScore}`;
                const currentScore = (game.status === 'playing') ? calculateScore(opp.grid, true) : opp.score;

                // HINZUGEFÜGT: KI-Label
                const aiLabel = opp.isAI ? '<span class="text-xs text-slate-400">(KI)</span>' : '';

                oppContainer.innerHTML = `
                    <h2 class="text-md font-bold text-center text-red-400">${opp.name} ${aiLabel}</h2>
                    ${gridHtml}
                    <p class="text-center text-md font-semibold">Punkte: <span>${currentScore}</span> <span class="text-slate-400">${totalScoreDisplay}</span></p>
                `;
                opponentsAreaEl.appendChild(oppContainer);
            });

            // 2. Eigenes Feld (Spieler) rendern
            playerGridEl.innerHTML = '';
            me.grid.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card');
                
                if (card.discarded) {
                    cardEl.classList.add('discarded');
                    cardEl.textContent = 'X';
                } else if (card.faceUp) {
                    cardEl.classList.add('face-up');
                    cardEl.textContent = card.value;
                    cardEl.setAttribute('data-value', card.value);
                } else {
                    cardEl.classList.add('face-down');
                    cardEl.textContent = 'SKYJO';
                }
                
                // Klick-Listener nur hinzufügen, wenn Karte nicht abgeräumt ist
                if (!card.discarded) {
                    cardEl.addEventListener('click', () => onPlayerCardClick(index));
                }
                playerGridEl.appendChild(cardEl);
            });

            // 3. Punktestand aktualisieren
            const myCurrentScore = (game.status === 'playing') ? calculateScore(me.grid, true) : me.score;
            playerScoreEl.textContent = `${myCurrentScore} | Gesamt: ${me.totalScore}`;


            // 4. Stapel rendern
            renderDeck(game);

            // 5. Highlights und Nachrichten aktualisieren
            updateHighlightsAndMessage(game);
        }

        /**
         * Zeichnet die drei Stapel in der Mitte
         */
        function renderDeck(game) {
            // 1. Nachziehstapel (links)
            if (game.deck.length === 0) {
                deckPileEl.classList.add('opacity-50', 'cursor-not-allowed');
                deckPileEl.textContent = "LEER";
            } else {
                deckPileEl.classList.remove('opacity-50', 'cursor-not-allowed');
                deckPileEl.textContent = "SKYJO";
            }

            // 2. Gezogene Karte (Mitte)
            // Wird nur gerendert, wenn eine Karte ausgewählt ist (Phase DECK_DRAWN oder DISCARD_DRAWN)
            drawnCardAreaEl.innerHTML = '';
            drawnCardAreaEl.classList.add('placeholder');
            drawnCardAreaEl.classList.remove('face-up', 'highlight-player');
            drawnCardAreaEl.removeAttribute('data-value');

            if (game.selectedCard && (game.turnPhase === 'DECK_DRAWN' || game.turnPhase === 'DISCARD_DRAWN')) {
                drawnCardAreaEl.classList.remove('placeholder');
                drawnCardAreaEl.classList.add('face-up', 'highlight-player');
                drawnCardAreaEl.textContent = game.selectedCard.value;
                drawnCardAreaEl.setAttribute('data-value', game.selectedCard.value);
            }

            // 3. Ablagestapel (rechts)
            discardPileEl.innerHTML = '';
            discardPileEl.classList.remove('face-up', 'opacity-50', 'cursor-not-allowed');
            discardPileEl.removeAttribute('data-value');
            
            if (game.discardPile.length > 0) {
                // Zeigt immer die oberste Karte des *echten* Stapels
                const topDiscardCardValue = game.discardPile[game.discardPile.length - 1];
                discardPileEl.textContent = topDiscardCardValue;
                discardPileEl.setAttribute('data-value', topDiscardCardValue);
                discardPileEl.classList.add('face-up');
            } else {
                discardPileEl.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Aktualisiert die Highlights und die Nachrichtenleiste
         */
        function updateHighlightsAndMessage(game) {
            const amICurrentPlayer = game.players[game.currentPlayerIndex]?.id === userId;

            // Reset aller Highlights
            playerGridEl.classList.remove('highlight-grid');
            deckPileEl.classList.remove('highlight-player');
            discardPileEl.classList.remove('highlight-player');
            drawnCardAreaEl.classList.remove('highlight-player'); // vom mittleren Stapel
            turnIndicatorEl.classList.add('opacity-0', 'scale-90');

            if (!amICurrentPlayer) {
                const currentPlayerName = game.players[game.currentPlayerIndex]?.name || 'Jemand';
                setMessage(`${currentPlayerName} ist am Zug...`);
                return;
            }

            // Ich bin dran!
            turnIndicatorEl.classList.remove('opacity-0', 'scale-90');

            switch (game.turnPhase) {
                case 'DRAW':
                    setMessage("Du bist dran. Ziehe eine Karte.");
                    deckPileEl.classList.add('highlight-player');
                    // Nur highlighten, wenn Stapel nicht leer ist
                    if (game.discardPile.length > 0) {
                        discardPileEl.classList.add('highlight-player');
                    }
                    break;
                
                case 'DECK_DRAWN':
                    setMessage(`Gezogen: ${game.selectedCard.value}. Tauschen (klicke Karte) oder Ablegen (klicke Ablagestapel)?`);
                    playerGridEl.classList.add('highlight-grid');
                    discardPileEl.classList.add('highlight-player'); // Ziel zum Ablegen
                    // KORREKTUR: Gezogene Karte in der Mitte highlighten
                    drawnCardAreaEl.classList.add('highlight-player');
                    break;
                
                case 'DISCARD_DRAWN':
                    setMessage("Du MUSST diese Karte tauschen. Wähle eine deiner Karten.");
                    playerGridEl.classList.add('highlight-grid');
                    // KORREKTUR: Gezogene Karte in der Mitte highlighten
                    drawnCardAreaEl.classList.add('highlight-player');
                    break;
                
                case 'FLIP_REQUIRED':
                    setMessage("Du musst eine deiner VERDECKTEN Karten aufdecken.");
                    playerGridEl.classList.add('highlight-grid');
                    break;
            }
        }

        /**
         * Berechnet den Punktestand für ein Grid
         */
        function calculateScore(grid, visibleOnly = false) {
            return grid.reduce((total, card) => {
                if (card.discarded) return total;
                if (visibleOnly && !card.faceUp) return total;
                return total + card.value;
            }, 0);
        }

        /**
         * Hebt eine Karte kurz hervor
         */
        function highlightCard(gridEl, index, playerType = 'player') {
            if (!gridEl || !gridEl.children[index]) return;
            const cardEl = gridEl.children[index];
            if (cardEl) {
                // HINZUGEFÜGT: Unterscheidung
                const highlightClass = playerType === 'player' ? 'highlight-player' : 'highlight-ai';
                cardEl.classList.add(highlightClass);
                setTimeout(() => {
                    if (cardEl) cardEl.classList.remove('highlight-player', 'highlight-ai');
                }, 1000);
            }
        }

        // ===================================================================
        //
        // SPIELZUG-FUNKTIONEN (Aktionen)
        //
        // ===================================================================

        /**
         * Wird aufgerufen, wenn der Spieler auf den Nachziehstapel klickt
         */
        async function onDeckDraw() {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            const game = (await getDoc(gameDocRef)).data();
            
            // Schutz-Checks
            if (game.status !== 'playing') return;
            if (game.players[game.currentPlayerIndex].id !== userId) return;
            if (game.turnPhase !== 'DRAW') return;

            let { deck, discardPile } = game;

            // Deck neu mischen, falls leer
            if (deck.length === 0) {
                if (discardPile.length <= 1) {
                    showToast("Deck und Ablagestapel sind leer!", true);
                    return;
                }
                const topCard = discardPile.pop();
                deck = shuffleDeck(discardPile);
                discardPile = [topCard];
            }

            const drawnCard = deck.pop();
            
            await updateDoc(gameDocRef, {
                deck: deck,
                discardPile: discardPile,
                selectedCard: { value: drawnCard },
                turnPhase: 'DECK_DRAWN'
            });
        }

        /**
         * Wird aufgerufen, wenn der Spieler auf den Ablagestapel klickt
         */
        async function onDiscardPileClick() {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            const game = (await getDoc(gameDocRef)).data();
            
            // Schutz-Checks
            if (game.status !== 'playing') return;
            if (game.players[game.currentPlayerIndex].id !== userId) return;

            // Fall 1: Normaler Zug 'DRAW' -> Karte vom Ablagestapel nehmen
            if (game.turnPhase === 'DRAW') {
                if (game.discardPile.length === 0) return;

                const drawnCard = game.discardPile.pop();
                await updateDoc(gameDocRef, {
                    discardPile: game.discardPile, // bereits .pop()ed
                    selectedCard: { value: drawnCard },
                    turnPhase: 'DISCARD_DRAWN'
                });
            }
            // Fall 2: Phase 'DECK_DRAWN' -> Gezogene Karte ablegen
            else if (game.turnPhase === 'DECK_DRAWN') {
                const me = game.players.find(p => p.id === userId);
                const hasFaceDownCards = me.grid.some(card => !card.faceUp && !card.discarded);

                if (!hasFaceDownCards) {
                    showToast("Du musst tauschen! Alle deine Karten sind aufgedeckt.", true);
                    return;
                }

                game.discardPile.push(game.selectedCard.value);
                // REFAKTORIERT: Ruft discardAndFlip auf, OHNE Index
                await discardAndFlip(game, userId, null, game.discardPile);
            }
        }

        /**
         * Klick auf die mittlere "gezogene Karte" = Ablegen
         */
        function onDrawnCardClick() {
            // Diese Funktion leitet einfach an onDiscardPileClick weiter,
            // da dies der "Ablegen"-Aktion in Phase DECK_DRAWN entspricht.
            onDiscardPileClick();
        }

        /**
         * Wird aufgerufen, wenn der Spieler auf eine seiner Grid-Karten klickt
         */
        async function onPlayerCardClick(index) {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            const game = (await getDoc(gameDocRef)).data();
            
            // Schutz-Checks
            const me = game.players.find(p => p.id === userId);
            if (game.status !== 'playing' || !me) return;
            if (game.players[game.currentPlayerIndex].id !== userId) return;

            const clickedCard = me.grid[index];
            if (clickedCard.discarded) return;

            // Fall 1: Tauschen (nach Ziehen von Deck ODER Ablagestapel)
            if (game.turnPhase === 'DECK_DRAWN' || game.turnPhase === 'DISCARD_DRAWN') {
                // REFAKTORIERT: Übergibt 'userId' und die gezogene Karte
                await swapCard(game, userId, index, game.selectedCard.value, game.deck, game.discardPile);
            }
            // Fall 2: Karte muss aufgedeckt werden
            else if (game.turnPhase === 'FLIP_REQUIRED') {
                if (clickedCard.faceUp) {
                    showToast("Du musst eine VERDECKTE Karte aufdecken.", true);
                    return;
                }
                // REFAKTORIERT: Übergibt 'userId'
                await discardAndFlip(game, userId, index, game.discardPile);
            }
        }

        /**
         * Logik: Karte tauschen und Zug beenden
         * REFAKTORIERT: Akzeptiert playerId, newCardValue und optionalen Deck-Status
         */
        async function swapCard(game, playerId, index, newCardValue, updatedDeck, updatedDiscardPile) {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            
            const player = game.players.find(p => p.id === playerId);
            if (!player) return;

            const oldCard = player.grid[index];

            player.grid[index] = { value: newCardValue, faceUp: true, discarded: false };
            
            // Benutze die übergebenen Stapel (wichtig für KI-Züge) oder die aus dem Spiel
            const discardPile = updatedDiscardPile || game.discardPile;
            const deck = updatedDeck || game.deck;
            
            discardPile.push(oldCard.value);
            
            // Spalten-Check
            // REFAKTORIERT: Übergibt player.grid
            const clearedIndices = checkAndClearColumn(player.grid, index);
            if (clearedIndices.length > 0) {
                clearedIndices.forEach(i => {
                    if (!player.grid[i].discarded) {
                        discardPile.push(player.grid[i].value); // Abgeräumte Karten auf Stapel legen
                        player.grid[i].discarded = true;
                    }
                });
            }

            // Spieler-Objekt im 'players'-Array aktualisieren
            const updatedPlayers = game.players.map(p => p.id === playerId ? player : p);

            // Rundenende-Check
            const roundEndTriggered = triggerEndRoundCheck(game, player);
            
            // Batch-Update an Firebase
            const batch = writeBatch(db);
            batch.update(gameDocRef, {
                players: updatedPlayers,
                discardPile: discardPile,
                deck: deck,
                selectedCard: null,
                turnPhase: 'DRAW', // Zurücksetzen für nächsten Spieler
            });
            await batch.commit();

            // Highlighten (nur für den menschlichen Spieler, nicht für KI)
            if (playerId === userId) {
                highlightCard(playerGridEl, index, 'player');
                if (clearedIndices.length > 0) {
                    setTimeout(() => clearedIndices.forEach(i => highlightCard(playerGridEl, i, 'player')), 100);
                }
            } else if (player.isAI) {
                // Highlight für KI (verzögert, damit der State-Change sichtbar ist)
                const oppArea = document.getElementById(`grid-${player.id}`);
                if (oppArea) {
                     highlightCard(oppArea, index, 'ai');
                     if (clearedIndices.length > 0) {
                        setTimeout(() => clearedIndices.forEach(i => highlightCard(oppArea, i, 'ai')), 100);
                    }
                }
            }


            // KORREKTUR: 'if'-Bedingung entfernt. endTurn MUSS immer aufgerufen werden.
            // Übergibt das aktualisierte Spielobjekt
            game.players = updatedPlayers;
            game.discardPile = discardPile;
            game.deck = deck;
            game.selectedCard = null;
            game.turnPhase = 'DRAW';
            await endTurn(gameDocRef, game, roundEndTriggered);
        }

        /**
         * Logik: Karte ablegen, eigene aufdecken und Zug beenden
         * REFAKTORIERT: Akzeptiert playerId und optionalen discardPile-Status
         * NEU: 'index' ist optional. Wenn null, wurde nur abgelegt (Fall 2 von onDiscardPileClick)
         */
        async function discardAndFlip(game, playerId, index, updatedDiscardPile) {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            
            const player = game.players.find(p => p.id === playerId);
            if (!player) return;

            const discardPile = updatedDiscardPile || game.discardPile;
            let roundEndTriggered = false;
            let clearedIndices = [];

            if (index !== null) {
                // Fall 1: Echte Karte aufdecken
                player.grid[index].faceUp = true;
                
                // Spalten-Check
                clearedIndices = checkAndClearColumn(player.grid, index);
                if (clearedIndices.length > 0) {
                    clearedIndices.forEach(i => {
                        if (!player.grid[i].discarded) {
                            discardPile.push(player.grid[i].value);
                            player.grid[i].discarded = true;
                        }
                    });
                }
                
                // Rundenende-Check
                roundEndTriggered = triggerEndRoundCheck(game, player);
            }
            // Fall 2: Nur Karte abgelegt (index === null), keine Karte aufdecken
            // (passiert, wenn man vom Deck zieht und direkt ablegt)
            // Hier wird kein Rundenende gecheckt, da keine Karte aufgedeckt wurde

            
            const updatedPlayers = game.players.map(p => p.id === playerId ? player : p);

            // Batch-Update an Firebase
            const batch = writeBatch(db);
            batch.update(gameDocRef, {
                players: updatedPlayers,
                discardPile: discardPile,
                selectedCard: null,
                turnPhase: 'DRAW'
            });
            await batch.commit();
            
            // Highlighten (nur für Mensch und wenn index da)
            if (index !== null) {
                if (playerId === userId) {
                    highlightCard(playerGridEl, index, 'player');
                    if (clearedIndices.length > 0) {
                        setTimeout(() => clearedIndices.forEach(i => highlightCard(playerGridEl, i, 'player')), 100);
                    }
                } else if (player.isAI) {
                     const oppArea = document.getElementById(`grid-${player.id}`);
                     if (oppArea) {
                        highlightCard(oppArea, index, 'ai');
                        if (clearedIndices.length > 0) {
                            setTimeout(() => clearedIndices.forEach(i => highlightCard(oppArea, i, 'ai')), 100);
                        }
                    }
                }
            }


            // KORREKTUR: 'if'-Bedingung entfernt. endTurn MUSS immer aufgerufen werden.
            game.players = updatedPlayers;
            game.discardPile = discardPile;
            game.selectedCard = null;
            game.turnPhase = 'DRAW';
            await endTurn(gameDocRef, game, roundEndTriggered);
        }

        /**
         * Prüft auf Spalten-Clear (3 gleiche)
         * REFAKTORIERT: Nimmt grid entgegen
         */
        function checkAndClearColumn(grid, changedIndex) {
            const col = changedIndex % 4;
            const colIndices = [col, col + 4, col + 8];
            
            const cards = colIndices.map(i => grid[i]);
            
            // Alle müssen aufgedeckt und nicht bereits abgeräumt sein
            if (cards.some(c => !c || !c.faceUp || c.discarded)) return [];
            
            const firstValue = cards[0].value;
            if (cards.every(c => c.value === firstValue)) {
                return colIndices; // Gibt die Indizes zurück, die abgeräumt werden sollen
            }
            return [];
        }

        /**
         * Prüft, ob der Spieler die Runde beendet hat
         * REFAKTORIERT: Nimmt player-Objekt entgegen
         */
        function triggerEndRoundCheck(game, player) {
            if (game.lastRoundTriggered) return false; // Runde wurde bereits beendet

            const allCardsFlipped = player.grid.every(card => card.faceUp || card.discarded);
            if (allCardsFlipped) {
                return true; // Ja, dieser Zug beendet die Runde
            }
            return false;
        }

        /**
         * Beendet den Zug und rückt zum nächsten Spieler
         */
        async function endTurn(gameDocRef, game, roundEndTriggered) {
            let { currentPlayerIndex, lastRoundTriggered, playerWhoEndedRoundId, players, hostId } = game;
            
            const nextPlayerIndex = (currentPlayerIndex + 1) % players.length;
            const nextPlayer = players[nextPlayerIndex];

            // Update-Objekt vorbereiten
            let updateData = {
                currentPlayerIndex: nextPlayerIndex
            };

            // Fall 1: Jemand hat gerade die Runde beendet
            if (roundEndTriggered && !lastRoundTriggered) {
                updateData.lastRoundTriggered = true;
                updateData.playerWhoEndedRoundId = players[currentPlayerIndex].id;
                // Speichere den neuen Status für die KI-Prüfung
                lastRoundTriggered = true; 
                playerWhoEndedRoundId = players[currentPlayerIndex].id;
            }
            // Fall 2: Die letzte Runde läuft bereits
            else if (lastRoundTriggered) {
                // Prüfen, ob der nächste Spieler der ist, der die Runde beendet hat
                if (nextPlayer.id === playerWhoEndedRoundId) {
                    // Die Runde ist jetzt vorbei!
                    await calculateFinalScores(gameDocRef, game);
                    return; // Nicht den Zug weitergeben, sondern Scores berechnen
                }
            }

            // Normaler Zug oder nächster Spieler in der letzten Runde
            await updateDoc(gameDocRef, updateData);

            // HINZUGEFÜGT: KI-Zug-Logik (wird nur vom Host ausgeführt)
            if (nextPlayer.isAI && hostId === userId) {
                // Holt den allerneuesten Spielstatus, um Race Conditions zu vermeiden
                // (Wichtig, falls ein Mensch vorher schnell geklickt hat)
                const freshGameSnap = await getDoc(gameDocRef);
                if (freshGameSnap.exists()) {
                    const freshGame = freshGameSnap.data();
                    // Stelle sicher, dass die KI immer noch dran ist (falls der Host schnell geklickt hat)
                    if (freshGame.players[freshGame.currentPlayerIndex].id === nextPlayer.id) {
                        // Kurze Verzögerung, damit Menschen den Zug sehen
                        setTimeout(() => {
                            runAITurn(freshGame, nextPlayer);
                        }, 1500);
                    }
                }
            }
        }


        // ===================================================================
        //
        // HINZUGEFÜGT: KI-SPIEL-LOGIK (Wird nur vom Host ausgeführt)
        //
        // ===================================================================

        /**
         * Führt einen kompletten KI-Zug aus (nur Host)
         */
        async function runAITurn(game, aiPlayer) {
            // Spiel-Referenz
            const gameDocRef = doc(db, getGameCollectionPath(), game.id || currentGameId);
            const difficulty = AI_DIFFICULTY[aiPlayer.difficulty];
            const topDiscard = game.discardPile.length > 0 ? game.discardPile[game.discardPile.length - 1] : null;

            // 1. Entscheidung: Ablagestapel nehmen?
            const bestSwapDiscard = findBestAISwap(aiPlayer.grid, topDiscard, difficulty);

            if (topDiscard !== null && bestSwapDiscard && bestSwapDiscard.benefit > difficulty.DISCARD_TAKE_THRESHOLD) {
                // AKTION: Nimmt vom Ablagestapel
                let { discardPile } = game;
                const drawnCard = discardPile.pop();
                
                // Ruft die refaktorierte swapCard-Funktion auf
                await swapCard(game, aiPlayer.id, bestSwapDiscard.index, drawnCard, game.deck, discardPile);
            } else {
                // AKTION: Nimmt vom Nachziehstapel
                let { deck, discardPile } = game;

                // Deck neu mischen, falls leer
                if (deck.length === 0) {
                    if (discardPile.length <= 1) { 
                        // KI kann nichts tun, Zug wird einfach weitergegeben
                        await endTurn(doc(db, getGameCollectionPath(), game.id), game, false);
                        return;
                    }
                    const topCard = discardPile.pop();
                    deck = shuffleDeck(discardPile);
                    discardPile = [topCard];
                }

                const drawnCard = deck.pop();
                const bestSwapDeck = findBestAISwap(aiPlayer.grid, drawnCard, difficulty);
                const hasFaceDownCards = aiPlayer.grid.some(card => !card.faceUp && !card.discarded);
                
                let doDiscardAndFlip = false;
                
                // Entscheidung: Ablegen oder Tauschen?
                if (hasFaceDownCards && (!bestSwapDeck || bestSwapDeck.benefit < difficulty.DECK_SWAP_GOOD_CARD_THRESHOLD)) {
                    doDiscardAndFlip = true;
                }

                if (doDiscardAndFlip) {
                    // AKTION: Gezogene Karte ablegen und eine umdrehen
                    discardPile.push(drawnCard);
                    const flipIndex = aiPlayer.grid.findIndex(c => !c.faceUp && !c.discarded);
                    
                    if (flipIndex !== -1) {
                        await discardAndFlip(game, aiPlayer.id, flipIndex, discardPile);
                    } else {
                        // Alle Karten aufgedeckt, muss tauschen (sollte von oberer Logik abgefangen werden)
                        // Führt Tausch mit schlechtester Karte durch
                        const swapIndex = bestSwapDeck ? bestSwapDeck.index : findWorstCardIndex(aiPlayer.grid, drawnCard);
                        await swapCard(game, aiPlayer.id, swapIndex, drawnCard, deck, discardPile);
                    }
                } else {
                    // AKTION: Gezogene Karte tauschen
                    let swapIndex;
                    if (bestSwapDeck) {
                        swapIndex = bestSwapDeck.index;
                    } else {
                        // Muss tauschen (alle aufgedeckt), aber keine gute Karte. Nimm die schlechteste.
                        swapIndex = findWorstCardIndex(aiPlayer.grid, drawnCard);
                    }
                    
                    await swapCard(game, aiPlayer.id, swapIndex, drawnCard, deck, discardPile);
                }
            }
        }
        
        /**
         * HINZUGEFÜGT: KI-Helferfunktion (pure function)
         * Findet den besten Tausch für eine neue Karte.
         */
        function findBestAISwap(grid, newCardValue, difficulty) {
            if (newCardValue === null) return null;

            let bestSwapIndex = -1;
            let maxBenefit = -Infinity;
            
            // 1. Prüfe aufgedeckte Karten
            for (let i = 0; i < grid.length; i++) {
                const card = grid[i];
                if (card.faceUp && !card.discarded) {
                    const benefit = card.value - newCardValue;
                    if (benefit > maxBenefit) {
                        maxBenefit = benefit;
                        bestSwapIndex = i;
                    }
                }
            }
            
            // 2. Prüfe Tausch mit verdeckten Karten
            const benefitVsFaceDown = difficulty.ASSUMED_FACEDOWN_VALUE - newCardValue;
            
            if (benefitVsFaceDown > maxBenefit) {
                const faceDownIndex = grid.findIndex(c => !c.faceUp && !c.discarded);
                if (faceDownIndex !== -1) {
                    maxBenefit = benefitVsFaceDown;
                    bestSwapIndex = faceDownIndex;
                }
            }

            if (bestSwapIndex === -1) return null;
            return { index: bestSwapIndex, benefit: maxBenefit };
        }

        /**
         * HINZUGEFÜGT: KI-Helferfunktion (pure function)
         * Findet die schlechteste Karte (geringster Tausch-Nutzen)
         */
        function findWorstCardIndex(grid, newCardValue) {
             let worstCardIndex = -1;
             let minBenefit = Infinity;
             for (let i = 0; i < grid.length; i++) {
                 const card = grid[i];
                 if (card.faceUp && !card.discarded) {
                     const benefit = card.value - newCardValue;
                     if (benefit < minBenefit) {
                         minBenefit = benefit;
                         worstCardIndex = i;
                     }
                 }
             }
             // Fallback, falls alles abgeräumt ist
             if (worstCardIndex === -1) {
                worstCardIndex = grid.findIndex(c => !c.discarded);
             }
             return worstCardIndex;
        }


        // ===================================================================
        //
        // SPIEL-MANAGEMENT (Start, Rundenende, Spielende)
        //
        // ===================================================================

        /**
         * Startet das Spiel (nur Host)
         */
        async function startGame() {
            loaderEl.classList.remove('hidden');
            loaderTextEl.textContent = "Starte Spiel...";

            try {
                const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
                const game = (await getDoc(gameDocRef)).data();
                
                if (game.hostId !== userId) {
                    throw new Error("Nur der Host kann das Spiel starten.");
                }

                // HINZUGEFÜGT: KI-Spieler basierend auf Settings erstellen
                const humanPlayers = game.players.filter(p => !p.isAI);
                const aiPlayers = [];
                const numAI = game.settings.numAI || 0;
                
                for (let i = 0; i < numAI; i++) {
                    // Sicherstellen, dass die Gesamtspielerzahl 4 nicht übersteigt
                    if (humanPlayers.length + aiPlayers.length >= 4) break;
                    
                    aiPlayers.push({
                        id: `ai_${i + 1}_${game.id.substring(0, 4)}`, // Eindeutige ID
                        name: `KI ${i + 1}`,
                        isHost: false,
                        isAI: true,
                        difficulty: game.settings.aiDifficulty.toUpperCase(),
                        grid: [],
                        score: 0,
                        totalScore: 0
                    });
                }
                
                const allPlayers = [...humanPlayers, ...aiPlayers];
                
                let deck = createDeck();
                deck = shuffleDeck(deck);
                
                // Karten an Spieler austeilen und 2 aufdecken
                allPlayers.forEach(player => {
                    player.grid = [];
                    for (let i = 0; i < 12; i++) {
                        if (deck.length > 0) player.grid.push({ value: deck.pop(), faceUp: false, discarded: false });
                    }
                    flipRandomCards(player.grid, game.settings.flippedCards);
                    player.score = 0; // Stellt sicher, dass Score 0 ist
                });
                
                const discardPile = (deck.length > 0) ? [deck.pop()] : [0];
                
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    players: allPlayers, // HINZUGEFÜGT: Beinhaltet jetzt KI-Spieler
                    deck: deck,
                    discardPile: discardPile,
                    currentPlayerIndex: 0,
                    turnPhase: 'DRAW',
                    lastRoundTriggered: false,
                    playerWhoEndedRoundId: null,
                    lastRoundScores: []
                });

            } catch (error) {
                console.error("Fehler beim Spielstart:", error);
                loaderEl.classList.add('hidden');
                showToast(error.message, true);
            }
        }

        /**
         * Deckt 'count' zufällige Karten auf
         */
        function flipRandomCards(grid, count) {
            const faceDownIndices = [];
            grid.forEach((card, index) => {
                if (!card.faceUp) faceDownIndices.push(index);
            });
            shuffleDeck(faceDownIndices);
            for (let i = 0; i < count && i < faceDownIndices.length; i++) {
                grid[faceDownIndices[i]].faceUp = true;
            }
        }

        /**
         * Mischt ein Deck
         */
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        /**
         * Erstellt das 150-Karten-Deck
         */
        function createDeck() {
            const deck = [];
            // 5x -2
            for (let i = 0; i < 5; i++) deck.push(-2);
            // 10x -1
            for (let i = 0; i < 10; i++) deck.push(-1);
            // 15x 0
            for (let i = 0; i < 15; i++) deck.push(0);
            // 10x 1-12
            for (let val = 1; val <= 12; val++) {
                for (let i = 0; i < 10; i++) deck.push(val);
            }
            return deck; // 150 Karten
        }

        /**
         * Berechnet die finalen Scores und zeigt das Modal an
         */
        async function calculateFinalScores(gameDocRef, game) {
            // Alle Karten aufdecken und finale Spalten prüfen
            game.players.forEach(player => {
                player.grid.forEach(card => card.faceUp = true);
                for (let col = 0; col < 4; col++) {
                    const clearedIndices = checkAndClearColumn(player.grid, col);
                    if (clearedIndices.length > 0) {
                        clearedIndices.forEach(i => player.grid[i].discarded = true);
                    }
                }
                // Rundenpunkte berechnen
                player.score = calculateScore(player.grid);
            });

            // Straf-Regel (Skyjo-Regel)
            const endingPlayer = game.players.find(p => p.id === game.playerWhoEndedRoundId);
            const scores = game.players.map(p => p.score);
            const lowestScore = Math.min(...scores);

            if (endingPlayer && endingPlayer.score > lowestScore && endingPlayer.score > 0) {
                endingPlayer.score *= 2;
            }

            // Gesamtpunkte aktualisieren
            let gameIsOver = false;
            game.players.forEach(p => {
                p.totalScore += p.score;
                if (p.totalScore >= game.settings.goalScore) {
                    gameIsOver = true;
                }
            });
            
            // Scores für "Letzte Runde"-Anzeige speichern
            const lastRoundScores = game.players.map(p => ({ id: p.id, name: p.name, score: p.score }));

            await updateDoc(gameDocRef, {
                status: gameIsOver ? 'game-over' : 'round-over',
                players: game.players,
                lastRoundScores: lastRoundScores // Speichert die Punkte dieser Runde
            });
            
            // Modal wird durch handleGameUpdate() angezeigt
        }

        /**
         * Zeigt das Modal am Runden- oder Spielende
         */
        function showEndRoundModal(game) {
            modalScoresContainerEl.innerHTML = '';
            
            // Sortiert nach Runden-Punktestand
            const sortedPlayers = [...game.players].sort((a, b) => a.score - b.score);
            
            sortedPlayers.forEach(p => {
                const scoreDiv = document.createElement('div');
                // HINZUGEFÜGT: KI-Label im Score
                const nameLabel = p.isAI ? `${p.name} (${p.difficulty})` : p.name;
                const colorClass = p.isAI ? 'bg-slate-700' : (p.id === userId ? 'bg-blue-900/50' : 'bg-red-900/50');
                const textColorClass = p.isAI ? 'text-slate-300' : (p.id === userId ? 'text-blue-300' : 'text-red-300');


                scoreDiv.className = `p-3 rounded-lg ${colorClass}`;
                scoreDiv.innerHTML = `
                    <p class="font-semibold text-lg ${textColorClass}">${nameLabel}</p>
                    <p>Runde: <span class="font-bold text-xl">${p.score}</span></p>
                    <p>Gesamt: <span class="font-bold text-xl">${p.totalScore}</span></p>
                `;
                modalScoresContainerEl.appendChild(scoreDiv);
            });

            // Gewinner ermitteln
            const roundWinner = sortedPlayers[0];
            const roundWinners = sortedPlayers.filter(p => p.score === roundWinner.score);

            if (game.status === 'game-over') {
                modalTitleEl.textContent = "Spiel beendet!";
                const gameWinner = [...game.players].sort((a, b) => a.totalScore - b.totalScore)[0];
                const gameWinners = game.players.filter(p => p.totalScore === gameWinner.totalScore);

                if (gameWinners.length > 1) {
                    modalWinnerEl.textContent = "Unentschieden!";
                    modalWinnerEl.className = "text-2xl font-semibold mb-8 text-yellow-400";
                } else {
                    modalWinnerEl.textContent = `${gameWinner.name} gewinnt das Spiel!`;
                    modalWinnerEl.className = "text-2xl font-semibold mb-8 text-blue-400";
                }
                
                nextRoundButtonEl.textContent = "Neues Spiel (Lobby)";
            } else {
                // Rundenende
                modalTitleEl.textContent = "Runde beendet!";
                if (roundWinners.length > 1) {
                    modalWinnerEl.textContent = "Runde Unentschieden!";
                    modalWinnerEl.className = "text-2xl font-semibold mb-8 text-yellow-400";
                } else {
                    modalWinnerEl.textContent = `${roundWinner.name} gewinnt die Runde!`;
                    modalWinnerEl.className = "text-2xl font-semibold mb-8 text-blue-400";
                }
                nextRoundButtonEl.textContent = "Nächste Runde";
            }
            
            // Nur Host kann nächste Runde/Spiel starten
            if (game.hostId === userId) {
                nextRoundButtonEl.style.display = 'block';
            } else {
                nextRoundButtonEl.style.display = 'none';
            }

            modalEl.classList.remove('hidden');
            modalEl.classList.add('flex');
        }

        /**
         * Startet die nächste Runde (nur Host)
         */
        async function startNextRound() {
            const gameDocRef = doc(db, getGameCollectionPath(), currentGameId);
            const game = (await getDoc(gameDocRef)).data();
            
            if (game.hostId !== userId) return;

            if (game.status === 'game-over') {
                // Zurück zur Lobby
                // (Spiel wird nicht gelöscht, Host könnte "neu starten" klicken)
                // HINZUGEFÜGT: Setzt Spieler zurück (entfernt KI)
                const humanPlayers = game.players.filter(p => !p.isAI);
                humanPlayers.forEach(p => {
                    p.grid = [];
                    p.score = 0;
                    p.totalScore = 0; // Setzt das gesamte Spiel zurück
                });
                
                await updateDoc(gameDocRef, {
                    status: 'lobby',
                    players: humanPlayers, // Nur menschliche Spieler bleiben
                    lastRoundScores: [],
                    lastRoundTriggered: false,
                    playerWhoEndedRoundId: null,
                    deck: [],
                    discardPile: []
                });
                // handleGameUpdate schickt uns zur Lobby
            } else {
                // Nächste Runde vorbereiten
                loaderEl.classList.remove('hidden');
                loaderTextEl.textContent = "Starte nächste Runde...";

                let deck = createDeck();
                deck = shuffleDeck(deck);
                
                game.players.forEach(player => {
                    player.grid = [];
                    for (let i = 0; i < 12; i++) {
                        if (deck.length > 0) player.grid.push({ value: deck.pop(), faceUp: false, discarded: false });
                    }
                    flipRandomCards(player.grid, game.settings.flippedCards);
                    player.score = 0; // Wichtig: Runden-Score zurücksetzen
                });
                
                const discardPile = (deck.length > 0) ? [deck.pop()] : [0];
                
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    players: game.players,
                    deck: deck,
                    discardPile: discardPile,
                    currentPlayerIndex: (game.currentPlayerIndex + 1) % game.players.length, // Startspieler rotiert
                    turnPhase: 'DRAW',
                    lastRoundTriggered: false,
                    playerWhoEndedRoundId: null,
                    selectedCard: null,
                    // lastRoundScores bleibt (wird in handleGameUpdate angezeigt)
                });
            }
        }


        // --- Initialisierung ---
        document.addEventListener('DOMContentLoaded', () => {
            setupLobbyListeners();
            setupGameListeners();
            initFirebase();
        });

    </script>
</body>
</html>

